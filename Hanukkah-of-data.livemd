# Hanukkah of Data ðŸ•Ž -- 5783

```elixir
Mix.install([:csv])

# there is a comma in citizenstatezip as well
customers =
  "./data/noahs-customers.csv"
  |> Path.expand(__DIR__)
  |> File.stream!()
  |> CSV.decode()

# there is a comma in citizenstatezip as well
orders =
  "./data/noahs-orders.csv"
  |> Path.expand(__DIR__)
  |> File.stream!()
  |> CSV.decode()

# there is a comma in citizenstatezip as well
items =
  "./data/noahs-orders_items.csv"
  |> Path.expand(__DIR__)
  |> File.stream!()
  |> CSV.decode()

# there is a comma in citizenstatezip as well
products =
  "./data/noahs-products.csv"
  |> Path.expand(__DIR__)
  |> File.stream!()
  |> CSV.decode()

# own CSV parsing attempt
# |> Stream.map(&String.trim(&1))
# |> Stream.map(&String.split(&1, ","))
# |> Stream.map(fn [customerId, name, address, citizen, statezip, birthdate, phone] ->
# %{name: name, phone: phone}
# end)
# |> Stream.filter(fn
#   ["Timestamp" | _] -> false
#   [_, "NaN" | _] -> false
#   [timestamp | _] ->
#     IO.puts("filter -> #{timestamp}")
#     true
# end)
```

## Night 1

## Knowledge

* Noah's Market
* Noah is the granduncle
* database started 2017 (by cousin Alex, who is too busy)
* Store is in Manhatten, NY (NYC)
* I was buying bagels
* Aunt Sarah
* *rug* is missing (JD spec 2017)

<!-- livebook:{"break_markdown":true} -->

> Find the private investigator's phone number ðŸ‘€

```elixir
convert_to_code = fn letter ->
  # a = 0, z = 25
  char = letter - 97

  cond do
    # abc
    char <= 2 -> 2
    # def
    char <= 5 -> 3
    char <= 8 -> 4
    char <= 11 -> 5
    char <= 14 -> 6
    char <= 18 -> 7
    char <= 21 -> 8
    # xzy
    char <= 25 -> 9
    true -> raise "oh no"
  end
end

customers
|> Stream.drop(1)
|> Stream.map(fn {_ok, [_id, name, _add, _state, _birth, phone]} ->
  %{name: name, phone: phone}
end)
|> Stream.map(fn %{name: name, phone: phone} ->
  name_num =
    name
    |> String.split(" ")
    |> List.last()
    |> String.downcase()
    |> String.graphemes()
    |> Enum.map(fn s -> s |> String.to_charlist() |> hd end)
    |> Enum.map(convert_to_code)
    |> Enum.join("")

  new_phone =
    phone
    |> String.replace("-", "")

  %{name_num: name_num, phone: new_phone, orig_phone: phone}
end)
|> Stream.filter(fn %{name_num: name_num, phone: phone, orig_phone: _phone} ->
  String.contains?(name_num, phone)
end)
|> Enum.to_list()
|> List.first()
|> Map.get(:orig_phone)
```

## Night 2

JD's phone number

```elixir
qualified_customers =
  customers
  |> Stream.drop(1)
  |> Stream.map(fn {_ok, [customerId, name, address, state, _birth, phone]} ->
    %{customerId: customerId, name: name, phone: phone, state: state, address: address}
  end)
  |> Stream.filter(fn data ->
    parts = String.split(data.name, " ")

    if Enum.count(parts) > 2 do
      false
    else
      [first, last] = parts
      String.starts_with?(first, "J") && String.starts_with?(last, "D")
      # && String.contains?(data.state, "Manhattan")
    end
  end)

qualified_customers_id =
  qualified_customers
  |> Stream.map(&Map.get(&1, :customerId))
  |> Enum.to_list()

qualified_customers
|> Enum.to_list()
```

```elixir
qualified_orders =
  orders
  |> Stream.drop(1)
  |> Stream.map(fn {_ok, [orderId, customerId, ordered, _shipped, _items, _total]} ->
    %{orderId: orderId, customerId: customerId, ordered: ordered}
  end)
  |> Stream.map(fn data ->
    {:ok, date} = NaiveDateTime.from_iso8601(data.ordered)

    data
    |> Map.put(:ordered, date)
  end)
  |> Stream.filter(fn data ->
    date = Map.get(data, :ordered)
    date.year == 2017 && Enum.member?(qualified_customers_id, data.customerId)
  end)
```

```elixir
qualified_order_ids =
  qualified_orders
  |> Stream.map(fn data -> data.orderId end)
  |> Enum.to_list()

qualified_items =
  items
  |> Stream.drop(1)
  |> Stream.map(fn {_ok, [orderId, sku, _qty, _up]} -> %{orderId: orderId, sku: sku} end)
  |> Stream.filter(fn data ->
    Enum.member?(qualified_order_ids, data.orderId)
  end)

qualified_skus =
  qualified_items
  |> Stream.map(fn data -> data.sku end)
  |> Enum.to_list()
```

```elixir
products
|> Stream.drop(1)
|> Stream.map(fn {_ok, [sku, desc, _wc]} -> %{desc: String.downcase(desc), sku: sku} end)
|> Stream.filter(fn data ->
  Enum.member?(qualified_skus, data.sku)
  # && String.starts_with?(data.sku, "KIT") # prodcut category?
  # (String.contains?(data.desc, "coffee") ||
  # String.contains?(data.desc, "bagel"))
end)
|> Enum.to_list()
```

```elixir
qualified_products =
  products
  |> Stream.drop(1)
  |> Stream.map(fn {_ok, [sku, desc, _wc]} -> %{desc: String.downcase(desc), sku: sku} end)
  |> Stream.filter(fn data ->
    String.contains?(data.desc, "coffee") ||
      String.contains?(data.desc, "bagel")

    # || String.contains?(data.desc, "clean")
  end)

# outputs 10 items
# |> Enum.to_list

skus =
  qualified_products
  |> Stream.map(fn data ->
    data.sku
  end)
  |> Enum.to_list()

interesting_order_ids =
  items
  |> Stream.drop(1)
  |> Stream.map(fn {_ok, [orderId, sku, _qty, _up]} -> %{orderId: orderId, sku: sku} end)
  |> Stream.filter(fn data ->
    Enum.member?(skus, data.sku)
  end)
  |> Stream.map(fn data ->
    data.orderId
  end)
  |> Enum.to_list()

interesting_orders =
  orders
  |> Stream.drop(1)
  |> Stream.map(fn {_ok, [orderId, customerId, ordered, _shipped, _items, _total]} ->
    %{orderId: orderId, customerId: customerId, ordered: ordered}
  end)
  |> Stream.filter(fn data -> Enum.member?(interesting_order_ids, data.orderId) end)
  |> Enum.to_list()
```

```elixir
# interesting_customers = customers
# |> Stream.filter(fn data -> Enum.member?(qualified_customers_id, data.customterId) end)
# |> Enum.to_list

customer_id =
  interesting_orders
  |> Stream.filter(fn data -> Enum.member?(qualified_customers_id, data.customerId) end)
  |> Stream.filter(fn data -> String.starts_with?(data.ordered, "2017-") end)
  # three items
  |> Enum.to_list()
  |> List.first()
  |> then(&Map.get(&1, :customerId))
```

```elixir
qualified_customers
|> Enum.find(fn data -> data.customerId == customer_id end)
|> Map.get(:phone)

# 516-994-3023 is wrong
```
